using System.Collections.Immutable;
using MagicOnion.Client.SourceGenerator.CodeAnalysis;
using Microsoft.CodeAnalysis;

namespace MagicOnion.Client.SourceGenerator;

public partial class MagicOnionClientSourceGenerator
{
    public const string SourceGeneratorAttributesHintName = "MagicOnionClientSourceGeneratorAttributes.g.cs";
    public const string MagicOnionClientGenerationAttributeName = "MagicOnionClientGenerationAttribute";
    public const string MagicOnionClientGenerationAttributeFullName = $"MagicOnion.Client.{MagicOnionClientGenerationAttributeName}";

    static void AddAttributeSources(Action<string, string> addSource)
    {
        addSource(SourceGeneratorAttributesHintName, $$"""
            // <auto-generated />
            namespace MagicOnion.Client
            {
                /// <summary>
                /// Marker attribute for generating clients of MagicOnion.
                /// The source generator collects the classes specified by this attribute and uses them to generate source.
                /// </summary>
                [global::System.Diagnostics.Conditional("__MagicOnion_Client_SourceGenerator__DesignTimeOnly__")]
                [global::System.AttributeUsage(global::System.AttributeTargets.Class, AllowMultiple = false)]
                internal class {{MagicOnionClientGenerationAttributeName}} : global::System.Attribute
                {
                    /// <summary>
                    /// Gets or sets whether to disable automatically calling `Register` during start-up. (Automatic registration requires .NET 5+ or Unity)
                    /// </summary>
                    public bool DisableAutoRegistration { get; init; }

                    /// <summary>
                    /// Gets or set the serializer used for message serialization. The default value is <see cref="GenerateSerializerType.MessagePack"/>.
                    /// </summary>
                    public global::MagicOnion.Client.GenerateSerializerType Serializer { get; init; } = global::MagicOnion.Client.GenerateSerializerType.MessagePack;

                    /// <summary>
                    /// Gets or set the namespace of pre-generated MessagePackFormatters. The default value is <c>MessagePack.Formatters</c>.
                    /// </summary>
                    public string MessagePackFormatterNamespace { get; init; } = "MessagePack.Formatters";

                    public global::System.Type[] TypesContainedInTargetAssembly { get; }
            
                    /// <param name="typesContainedInTargetAssembly">Types contained in the scan target assembly</param>
                    public {{MagicOnionClientGenerationAttributeName}}(params global::System.Type[] typesContainedInTargetAssembly)
                    {
                        TypesContainedInTargetAssembly = typesContainedInTargetAssembly;
                    }
                }

                // This enum must be mirror of `SerializerType` (MagicOnionClientSourceGenerator)
                internal enum GenerateSerializerType
                {
                    MessagePack = 0,
                    MemoryPack = 1,
                }
            }
            """);
    }

    static void Generate(GenerationContext context, ImmutableArray<SyntaxNode> interfaces, Compilation compilation, ReferenceSymbols referenceSymbols)
    {
        var interfaceSymbols = interfaces.Select(x => (INamedTypeSymbol)compilation.GetSemanticModel(x.SyntaxTree).GetDeclaredSymbol(x)!).ToImmutableArray();
        Generate(context, interfaceSymbols, referenceSymbols);
    }

    static void Generate(GenerationContext context, ImmutableArray<INamedTypeSymbol> interfaceSymbols, ReferenceSymbols referenceSymbols)
    {
        var (serviceCollection, diagnostics) = MethodCollector.Collect(interfaceSymbols, referenceSymbols, context.SourceProductionContext.CancellationToken);
        var generated = MagicOnionClientGenerator.Generate(context, serviceCollection, context.SourceProductionContext.CancellationToken);

        foreach (var diagnostic in diagnostics)
        {
            context.SourceProductionContext.ReportDiagnostic(diagnostic);
        }

        foreach (var (path, source) in generated)
        {
            context.SourceProductionContext.AddSource(path, source);
        }
    }
}
